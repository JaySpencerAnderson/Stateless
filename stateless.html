<html>
	<head>
		<title>Compute Schema for a Perfect Mondrian candidate</title>
		<meta http-equiv="Content-Type" content="text/html;charset=ISO-8859-1">
	</head>
	<body>
	<canvas id="canvas" height="200" width="800" ></canvas>
	<p id="stx"></p>

<script>
// Stateless because these algorithms do not record prior schematics.
// Through knowledge of its own algorithms, this determines whether a generated schematic
//  would have been generated earlier in the sequence.  It is not comprehensively finding
//  ALL prior generated sequences yet.
// After generating a schematic and checking for some things that would make results invalid
//  (see isValid), The intent is to go through an estimating process to see if it looks like
//  congruent rectangles would result as would happen with the 5 spiral.  Generally speaking,
//  schematics which display some symmetry will have congruences that reflect that symmetry.
//  So perhaps that portends some additional shortcuts.
// It does look like the estimation process will be relatively quick to get to a point where 
//  it can tell if some rectangles in the solution are congruent.  It still will not determine
//  whether there is an integral solution.
// I'm probably going to display results in 3 separate canvases:
//  1) Solution contains congruencies
//  2) Solution contains no congruencies 
//  3) Unable to determine solution (because I may be limiting the algorithm to 
//      fewer guesses than required).


	var size=4;
	var canvas=document.getElementById("canvas");
	var ctx=canvas.getContext("2d");
	document.getElementById("stx").innerHTML="";

	function Rectangle(_x, _y, _w, _h){
		this.x = _x;
		this.y = _y;
		this.w = _w;
		this.h = _h;

		this.upperBorder = this.lowerBorder = this.leftBorder = this.rightBorder = undefined;

		this.overlap = function(r) {
			return (Math.max(r.x, this.x) < Math.min(r.x + r.w, this.x + this.w)
			&&	Math.max(r.y, this.y) < Math.min(r.y + r.h, this.y + this.h));
		}

		this.setLeftBorder = function(n){
			this.leftBorder = n;
		}
		this.setRightBorder = function(n){
			this.rightBorder = n;
		}
		this.setUpperBorder = function(n){
			this.upperBorder = n;
		}
		this.setLowerBorder = function(n){
			this.lowerBorder = n;
		}
	}
	function Border(value,type){
	// Need to add preceding and succeeding border
	//  to be used when guessing dimensions to make sure that we don't pass those borders.
	// Now thinking I might just need to check the extremes - 0 and this.size
		this.type=type;
		this.value=value;

		this.less=undefined;
		this.more=undefined;

		this.setType = function(type){
			this.type = type;
		}
		this.isConstant = function(){
			if(this.type === "K"){
				return true;
			}
			if(this.type === "C"){
				return true;
			}
			if(this.type === "G"){
				return true;
			}
			return false;
		}
		this.isGuess = function(){
			if(this.type === "G"){
				return true;
			}
			return false;
		}
		this.isSchematic = function(){
			if(this.type === "S"){
				return true;
			}
			return false;
		}
		this.initialize = function(){
			this.less=undefined;
			this.more=undefined;
		}
		// Vote to decrease this border
		// Remember the smallest amount
		this.decrease = function(amount){
			if(!this.isConstant()){
				if(this.less === undefined){
					this.less = amount;
				}
				else if(this.less > amount){
					this.less = amount;
				}
			}
		}
		// Vote to increase this border
		// Remember the smallest amount
		this.increase = function(amount){
			if(!this.isConstant()){
				if(this.more === undefined){
					this.more = amount;
				}
				else if(this.more > amount){
					this.more = amount;
				}
			}
		}
		this.votingResult = function(){
			if(this.less === undefined && this.more !== undefined){
				return this.more;
			}
			if(this.less !== undefined && this.more === undefined){
				return this.less;
			}
			return 0.0;
		}
		// After the voting is done, this border is being asked to move.
		this.move = function(){
			if(this.less !== undefined){
				this.value -= this.less;
			}
			else if(this.more !== undefined){
				this.value += this.more;
			}
		}
	}
	function Schematic(sz,context,scale){
		this.size = sz;
		this.ctx = context;
		this.scale = scale;
		this.xindent = scale;
		this.yindent = scale;
		this.stack = [];
		this.border = [];

		this.occupier = function(px, py){

			var r=new Rectangle(px,py,1,1);
			for(var i=0;i<this.stack.length;i++){
				if(r.overlap(this.stack[i])){
					return i;
				}
			}
			return -1;
		}
		this.overlap = function(r){
			for(i=0;i<this.stack.length;i++){
				if(this.stack[i].overlap(r)){
					return true;
				}
			}
			return false;
		}
		this.contains = function(r){
			return (r.x >= 0 && r.x < this.size
			&&	r.x+r.w > 0 && r.x+r.w <= this.size
			&&	r.y >= 0 && r.y < this.size
			&&	r.y+r.h > 0 && r.y+r.h <= this.size);
		}
		this.isFull = function() {
			for(var x=0;x<this.size;x++){
				for(var y=0;y<this.size;y++){
					if(this.occupier(x,y) < 0){
						return false;
					}
				}
			}
			return true;
		}
		this.draw = function(){
			if(this.isCompressible() === true){
				this.ctx.strokeStyle = "#FF0000";
			}
			else {
				this.ctx.strokeStyle = "#000000";
			}
			for(var i=0;i<this.stack.length;i++){
				var r=this.stack[i];
				ctx.strokeRect(this.xindent+ (this.scale*r.x), this.yindent+(this.scale*r.y), this.scale*r.w, this.scale*r.h);
			}
			this.xindent += this.scale * (this.size + 1);
			if(this.xindent + (this.scale * (this.size + 1)) > this.ctx.canvas.width){
				this.xindent = this.scale;
				this.yindent += this.scale * (this.size + 1);
			}
		}
		this.dump = function(){
			var current = document.getElementById("stx").innerHTML;
			current += "<table><tr><th>Number</th><th>x0</th><th>y0</th><th>x1</th><th>y1</th><th>area</th></tr>";
			for(var i=0;i<this.stack.length;i++){
				current+="<tr><td>" + i
				+ "</td><td>" + this.border[this.stack[i].leftBorder].value
				+ "</td><td>" + this.border[this.stack[i].upperBorder].value
				+ "</td><td>" + this.border[this.stack[i].rightBorder].value
				+ "</td><td>" + this.border[this.stack[i].lowerBorder].value
				+ "</td><td>" + this.area(i)
				+ "</td></tr>";
			}
			document.getElementById("stx").innerHTML=current + "</table>";

		}
		this.height = function(i){
			return this.border[this.stack[i].lowerBorder].value - this.border[this.stack[i].upperBorder].value;
		}
		this.width = function(i){
			return this.border[this.stack[i].rightBorder].value - this.border[this.stack[i].leftBorder].value;
		}
		this.area = function(i){
			// Area calculation based on borders, not on initial Height*Width.
			return this.height(i) * this.width(i);
		}
		this.isValid = function() {
			if(this.stack.length > 1){
				for(var i=0;i<this.stack.length-1;i++){
					var j=this.stack.length-1;
					if(this.stack[i].x == this.stack[j].x && this.stack[i].w == this.stack[j].w){
						if(this.stack[i].y == (this.stack[j].y+this.stack[j].h) 
						|| (this.stack[i].y+this.stack[i].h) == this.stack[j].y){
							return false;
						}
					}
					if(this.stack[i].y == this.stack[j].y && this.stack[i].h == this.stack[j].h){
						if(this.stack[i].x == (this.stack[j].x+this.stack[j].w)
						|| (this.stack[i].x+this.stack[i].w) == this.stack[j].x){
							return false;
						}
					}
					for(var j=i+1;j<this.stack.length;j++){
						if(this.stack[i].w === this.size && this.stack[j].w === this.size){
							return false;
						}
						if(this.stack[i].h === this.size && this.stack[j].h === this.size){
							return false;
						}
					}
				}
			}
			return true;
		}
		this.listSchematicBorders = function(r){
			var list=[];
			if(this.border[r.rightBorder].isSchematic()){
				list.push(r.rightBorder);
			}
			if(this.border[r.leftBorder].isSchematic()){
				list.push(r.leftBorder);
			}
			if(this.border[r.lowerBorder].isSchematic()){
				list.push(r.lowerBorder);
			}
			if(this.border[r.upperBorder].isSchematic()){
				list.push(r.upperBorder);
			}
			return list;
		}
		this.anySchematicBorders = function(){
			var slist=[];
			for(var i=0;i<this.border.length;i++){
				if(this.border[i].type === "S"){
					slist.push(i);
				}
			}
			return slist;
		}
		// Should this rectangle be a fixed size?  Normally the case unless we are guessing.
		this.isFixedSize = function(r){
			var count=0;
			var notConstant=undefined;
			if(this.border[r.rightBorder].isConstant()){
				count++;
			}
			else {
				notConstant=r.rightBorder;
			}
			if(this.border[r.leftBorder].isConstant()){
				count++;
			}
			else {
				notConstant=r.leftBorder;
			}
			if(this.border[r.lowerBorder].isConstant()){
				count++;
			}
			else {
				notConstant=r.lowerBorder;
			}
			if(this.border[r.upperBorder].isConstant()){
				count++;
			}
			else {
				notConstant=r.upperBorder;
			}
			if(count === 3){
				return notConstant;
			}
			return undefined;
		}
		this.setConstantBordersAsBefore = function(list){
			var targetArea = (this.size * this.size) / this.stack.length;
			var type = "C";
		}
		this.setConstantBorders = function(initialPass){
			var list=[];
			var targetArea = (this.size * this.size) / this.stack.length;
			var type = (initialPass?"K":"C");

			console.log(targetArea);
			// Set constant value borders, if any
			var changed=true;
			var distance;
			while(changed){
				changed=false;
				for(var i=0;i<this.stack.length;i++){
					// Does this rectangle have only one movable side?
					bn=this.isFixedSize(this.stack[i]);
					if(bn === this.stack[i].lowerBorder){
						distance = targetArea/this.width(i);
						this.border[bn].value = this.border[this.stack[i].upperBorder].value + distance;
						this.border[bn].setType(type);
						list.push(bn);
						changed=true;
//						console.log("lower border[" + bn + "] set to " + distance);
					}
					else if(bn === this.stack[i].upperBorder){
						distance = targetArea/this.width(i);
						this.border[bn].value = this.border[this.stack[i].lowerBorder].value - distance;
						this.border[bn].setType(type);
						list.push(bn);
						changed=true;
//						console.log("upper border[" + bn + "] set to " + distance);
					}
					else if(bn === this.stack[i].leftBorder){
						distance = targetArea/this.height(i);
						this.border[bn].value = this.border[this.stack[i].rightBorder].value - distance;
						this.border[bn].setType(type);
						list.push(bn);
						changed=true;
//						console.log("left border[" + bn + "] set to " + distance);
					}
					else if(bn === this.stack[i].rightBorder){
						distance = targetArea/this.height(i);
						this.border[bn].value = this.border[this.stack[i].leftBorder].value + distance;
						this.border[bn].setType(type);
						list.push(bn);
						changed=true;
//						console.log("right border[" + bn + "] set to " + distance);
					}
				}
			}
			return list;
		}
		this.smallestRectangle = function(){
			var smallest=this.area(0);
			var remember=0;
			for(var i=1;i<this.stack.length;i++){
				var area=this.area(i);
				if(area < smallest){
					smallest = area;
					remember = i;
				}
			}
//			console.log("Smallest: " + smallest + "(" + remember + ")");
			if(smallest <= 0){
				return undefined;
			}
			return {index: remember, value: smallest};
		}
		this.estimateBorders = function(g,list,d){
			var targetArea = (this.size * this.size) / this.stack.length;
			var increment = 0.0625;
			console.log(targetArea);
			// Approach is to first to adjust guess by 0.1, then 0.01, then 0.001, etc.
			//  Adjustment is deemed good if the smallest (or maybe largest) rectangle is changing toward the target.
			//  If an adjustment moves past the target, back out the adjustment and reduce by a factor of 0.1.
			//  Continue until the adjustment is arbitrarily small (0.0000000001).
			// At that point, another routine will check to see if any 2 resulting rectangles are congruent.
			// Just found one schematic where there are no congruent rectangles.
			//
			// 1123
			// 4523
			// 4663
			// 4777
			//
			// record index and area of smallest rectangle
			// make small adjustment to guess
			// recheck smallest rectangle - is it smaller?  If not, were going in the right direction.
			//   otherwise, change the direction
			console.log(d.index, d.value);
			this.border[g].value+=increment;
//			var list=this.setConstantBorders(false);
		}
		this.adjustBorders = function(){

			this.setConstantBorders(true);

			// Look for a place to guess
			for(var i=0;i<this.stack.length;i++){
				var glist=this.listSchematicBorders(this.stack[i]);
				if(glist.length === 2){
					console.log("Guess on " + i);
					for(var j=0;j<glist.length;j++){
						// Set one of the two non-constant borders to a guess
						// Dont change the value of the border yet.
						this.border[glist[j]].setType("G");

						// set as many constant borders as possible
						var list=this.setConstantBorders(false);
						// Currently implementing only a single guess
						// Did that set all of the remaining borders?  If so,
						var xlist=this.anySchematicBorders();
						if(xlist.length === 0){
							var descriptor = this.smallestRectangle();
							if(descriptor !== undefined){
								//  start estimating process based on that sequence
								this.estimateBorders(glist[j], list, descriptor);
							}
						}
						
						// Afterwards, back out guess and subsequent
						this.border[glist[j]].setType("S");
						for(var k=0;k<list.length;k++){
							this.border[list[k]].setType("S");
						}
					}
					
				}
			}


		}

		this.initBorders = function(){
			this.border = [];
		}
		this.defineBorders = function(){
			var x,y;

			// Top
			this.border.push(new Border(0,"K"));
			for(x=0;x<this.size;x++){
				var i=this.occupier(x,0);
				this.stack[i].setUpperBorder(this.border.length-1);
			}
			// Left uses same edge border as top (both are 0)
			for(y=0;y<this.size;y++){
				var i=this.occupier(0,y);
				this.stack[i].setLeftBorder(this.border.length-1);
			}
			// Bottom
			this.border.push(new Border(this.size,"K"));
			for(x=0;x<this.size;x++){
				var i=this.occupier(x,this.size-1);
				this.stack[i].setLowerBorder(this.border.length-1);
			}
			// Right uses same edge border as Bottom (both are this.size)
			for(y=0;y<this.size;y++){
				var i=this.occupier(this.size-1,y);
				this.stack[i].setRightBorder(this.border.length-1);
			}
			// Interior
			// Horizontal
			var previous=0;
			for(y=1;y<this.size;y++){
				var lesser=undefined;
				var greater=undefined;
				for(x=0;x<this.size;x++){
					var lr=this.occupier(x,y-1);
					var gr=this.occupier(x,y);
					if(lr !== gr){
						if(lr !== lesser && gr !== greater){
							this.border.push(new Border(y,"S"));
							lesser=lr;
							greater=gr;
						}
						this.stack[lr].setLowerBorder(this.border.length-1);
						this.stack[gr].setUpperBorder(this.border.length-1);
					}
				}
			}
			// Vertical
			for(x=1;x<this.size;x++){
				var lesser=undefined;
				var greater=undefined;
				for(y=0;y<this.size;y++){
					var lr=this.occupier(x-1,y);
					var gr=this.occupier(x,y);
					if(lr !== gr){
						if(lr !== lesser && gr !== greater){
							this.border.push(new Border(x,"S"));
							lesser=lr;
							greater=gr;
						}
						this.stack[lr].setRightBorder(this.border.length-1);
						this.stack[gr].setLeftBorder(this.border.length-1);
					}
				}
			}
		}
		this.solve = function(){
			this.defineBorders();
			this.adjustBorders(0);
			this.dump();
			this.initBorders();
		}
		// 4x4 schematic checking isDuplicate and isOldNews passes 11 rectangles
		//  where 5 are actually duplicates
		// If I added a check to see if a border could be moved up or to the left
		//  without changing the basic schematic, it could catch 3 more.
		// Calling this isCompressable().
		// Also could write routine to see if some rotation/flip of schema would 
		//  result in schema earlier in cycle (duplicate).
		this.isOldNews = function(i){
			var mn=Math.min(this.stack[i].w, this.stack[i].h);
			if(this.stack[0].h > mn){
				return true;
			}
			if(this.stack[0].h < mn){
				return false;
			}
			var mx=Math.max(this.stack[i].w, this.stack[i].h);
			if(this.stack[0].w > mx){
				return true;
			}
			return false;
		}
		this.isCompressible = function() {
			// Horizontal
			var a,b,c;
			var ap,bp,cp,s;
			for(var y=0;y<this.size-2;y++){
				ap=bp=cp=s=undefined;
				var inside=false;
				for(var x=0;x<this.size;x++){
					a=this.occupier(x,y);
					b=this.occupier(x,y+1);
					c=this.occupier(x,y+2);
					if(inside === true && a !== ap && b !== bp && c !== cp && s < x-1){
						if(x+1 < this.size && this.occupier(x+1,y) === this.occupier(x+1,y+1)){
							return true;
						}
					}
					if(c !== cp && a === b && a !== c){
						if(ap === undefined){
							inside=true;
							s=x;
						}
						else if(ap !== undefined && ap === bp){
							inside=true;
							if(a !== ap || b !== bp){
								s=x;
							}
						}
					}
					else if(a !== b){
						inside=false;
					}
					ap=a;
					bp=b;
					cp=c;
//					if(inside){
//						console.log(" inside@",x);
//					}
//					else {
//						console.log(" outside@",x);
//					}
				}
				if(inside === true && s < this.size-1){
					return true;
				}
			}
			for(var x=0;x<this.size-2;x++){
				ap=bp=cp=s=undefined;
				var inside=false;
				for(var y=0;y<this.size;y++){
					a=this.occupier(x,y);
					b=this.occupier(x+1,y);
					c=this.occupier(x+2,y);
					if(inside === true && a !== ap && b !== bp && c !== cp && s < y-1){
						if(y+1 < this.size && this.occupier(x,y+1) === this.occupier(x+1,y+1)){
							return true;
						}
					}
					if(c !== cp && a === b && a !== c){
						if(ap === undefined){
							inside=true;
							s=y;
						}
						else if(ap !== undefined && ap === bp){
							inside=true;
							if(a !== ap || b !== bp){
								s=y;
							}
						}
					}
					else if(a !== b){
						inside=false;
					}
					ap=a;
					bp=b;
					cp=c;
//					if(inside){
//						console.log(" inside@",x);
//					}
//					else {
//						console.log(" outside@",x);
//					}
				}
				if(inside === true && s < this.size-1){
					return true;
				}
			}
			return false;
		}
		this.isDuplicate =function() {
			if(this.stack[0].w < this.stack[0].h){
				return true;
			}
			// Comment out these 3 lines if you want to see the effect of isCompressible
			// The compressible schematics will be in red.
			if(this.isCompressible()){
				return true;
			}
			var ur=this.occupier(this.size-1,0);
			if(this.isOldNews(ur)){
				return true;
			}
			var ll=this.occupier(0,this.size-1);
			if(this.isOldNews(ll)){
				return true;
			}
			var lr=this.occupier(this.size-1,this.size-1);
			if(this.isOldNews(lr)){
				return true;
			}
			return false;
		}

		this.fill = function() {
			for(var y=0;y<this.size;y++){
				for(var x=0;x<this.size;x++){
					if(this.occupier(x,y) < 0){
						for(var h=1;h<=(this.size-y);h++){
							for(var w=1;w<=(this.size-x);w++){
								var r=new Rectangle(x,y,w,h);
								if(this.contains(r) && !this.overlap(r)){
									this.stack.push(r);
									if(this.isValid()){
										if(this.isFull() && this.stack.length > 1){
											if(!this.isDuplicate()){
												this.draw();
												this.solve();
											}
											this.stack.pop();
											return;
										}
										this.fill();
									}
									this.stack.pop();
								}
							}
						}
						return;
					}
				}
			}
		}
		
	}
	var schema = new Schematic(size,ctx,8);

	schema.fill();
</script>
	</body>
</html>
